#!/usr/bin/env python3

# Copyright 2006-2024 Michael Cuffaro
#
# This file is part of mccal.
#
# mccal is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# mccal is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with mccal.  If not, see <http://www.gnu.org/licenses/>.

import argparse
import os
import re
import subprocess
import time
from datetime import datetime
from pathlib import Path


def is_processed(event_id, procfile):
  for line in procfile:
    line = line.strip('\n')
    if line == event_id:
      procfile.seek(0)
      return True
  procfile.seek(0)
  return False


def main(calfilename, procfilename, pausefile_name, sleep_secs, text_mode, send_mail, once_only,
         dev_mode):
  iterated_once = False
  while True:
    iterated_once = True
    # If the pause file is present, then sleep and check again on the next iteration:
    if os.path.isfile(pausefile_name):
      time.sleep(sleep_secs)
      continue

    calfile = open(calfilename)
    procfile = open(procfilename)
    curr_date = datetime.now()
    reminder_queue = []
    for next_line in calfile:
      next_line = next_line.strip('\n')

      # If the line is prefixed with 'SNOOZE', remove it from the line in memory:
      next_line = re.sub(r"^(SNOOZE )?", "", next_line)

      # Parse the rest into four fields:
      event_id, dom, tod, text = next_line.split(' ', maxsplit=3)
      _, event_id = event_id.split(':')

      # If the event has already been processed we do not need to do anything:
      if is_processed(event_id, procfile):
        continue

      # Possibly put the event into the reminder queue:
      year, month, day = dom.split('-')
      hour, minute = tod.split(':')
      appt_date = datetime(year=int(year), month=int(month), day=int(day), hour=int(hour),
                           minute=int(minute))

      if curr_date >= appt_date:
        # Add the text to the reminder queue along with the event's ID:
        reminder_queue.append(f"{event_id},{text}")

    for reminder in reminder_queue:
      # Extract the id
      id_to_send, text_to_send = reminder.split(',', maxsplit=1)

      remind_prog = "remind -t" if text_mode else "remind"
      remind_prog = f"./{remind_prog}" if dev_mode else remind_prog
      command = f"{remind_prog} {calfile.name} {procfile.name} {id_to_send} {text_to_send}"
      if text_mode:
        output = subprocess.run(command, shell=True, capture_output=True)
        print(output.stdout.decode().strip('\n'))
      else:
        # Run the command in the background:
        command = f"{command} &"
        output = subprocess.run(command, shell=True)

    procfile.close()
    calfile.close()
    if once_only and iterated_once:
      break
    time.sleep(sleep_secs)


if __name__ == "__main__":
  default_calfile = f"{str(Path.home())}/.mycalendar.txt"
  default_procfile = f"{str(Path.home())}/.mycalendar_processed.txt"
  default_pausefile = f"{str(Path.home())}/.pause_mccal"
  default_sleep = 300

  parser = argparse.ArgumentParser(description="Simple reminder calendar -- findappointment")
  parser.add_argument(
    '--cal_file', metavar='FILE',
    help=f"read from the calendar FILE instead of from '{default_calfile}'"
  )
  parser.add_argument(
    '--proc_file', metavar='FILE',
    help=f"use FILE for writing processed events to instead of '{default_procfile}'"
  )
  parser.add_argument(
    '--pause_file', metavar='FILE',
    help=(f"use the existence of FILE, instead of '{default_pausefile}', as an indication "
          "to findappointment that it should postpone any user notifications until the next "
          "iteration")
  )
  parser.add_argument(
    '--sleep', metavar='N',
    help=(f"sleep for N seconds, instead of the default {default_sleep}, between "
          "iterations"),
    type=int
  )
  parser.add_argument(
    '--text_mode',
    help="write all reminder notifications to the console",
    action='store_true'
  )
  parser.add_argument(
    '--mail',
    help="send an email to the configured addressee in addition to a notification",
    action='store_true'
  )
  parser.add_argument(
    '--once',
    help=('do not iterate; look once through the calendar file for reminders that are due, '
          'generate notifications, and exit.'),
    action='store_true'
  )
  parser.add_argument(
    '--dev',
    help='assume that all other mccal commands are in the working directory',
    action='store_true'
  )
  args = parser.parse_args()

  main(
    args.cal_file or default_calfile,
    args.proc_file or default_procfile,
    args.pause_file or default_pausefile,
    args.sleep or default_sleep,
    args.text_mode,
    args.mail,
    args.once,
    args.dev
  )
