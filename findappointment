#!/usr/bin/env python3

# Copyright 2006-2024 Michael Cuffaro
#
# This file is part of mccal.
#
# mccal is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# mccal is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with mccal.  If not, see <http://www.gnu.org/licenses/>.

import argparse
import os
import re
import subprocess
import sys
import time
from datetime import datetime
from pathlib import Path


def main(calfilename, pausefile_name, sleep_secs, text_mode, send_mail, once_only, dev_mode):
  # Remove any pending events from the calendar file at startup:
  calfile_contents = []
  pending_events = set()
  processed_events = set()
  with open(calfilename) as calfile:
    for i, next_line in enumerate(calfile):
      next_line = next_line.strip('\n')
      match = re.match(r"^((SNOOZE|PENDING|PROCESSED) )?ID:([0-9\.]+) ", next_line)
      if not match:
        print(f"Line {i} has invalid syntax: '{next_line}'", file=sys.stderr)
        sys.exit(1)
      match = match.groups()

      directive, event_id = match[1], match[2]
      calfile_contents.append(next_line)
      if directive == "PENDING":
        pending_events.add(event_id)
      elif directive == "PROCESSED":
        processed_events.add(event_id)

    incompletes = [
      event_id for event_id in pending_events if event_id not in processed_events
    ]
    if incompletes:
      # TODO: Also send an email to the administrator about this:
      print(
        f"The following reminders were found to be pending but not processed:\n"
        f"{', '.join(incompletes)}.\n"
        "No action is required. This is for information only.",
        file=sys.stderr
      )

  with open(calfilename, mode='w') as calfile:
    for line in calfile_contents:
      match = re.match(r"^((SNOOZE|PENDING|PROCESSED) )?ID:([0-9\.]+) ", line).groups()
      directive, event_id = match[1], match[2]
      if directive != "PENDING":
        print(line, file=calfile)

  # Now iterate:
  iterated_once = False
  while True:
    iterated_once = True
    # If the pause file is present, then sleep and check again on the next iteration:
    if os.path.isfile(pausefile_name):
      time.sleep(sleep_secs)
      continue

    calfile = open(calfilename)
    curr_date = datetime.now()
    reminder_queue = {}
    for next_line in calfile:
      next_line = next_line.strip('\n')

      # If the line begins with a directive, extract it and then remove it from the line:
      directive_pattern = r"^((SNOOZE|PENDING|PROCESSED) )?"
      directive = re.match(directive_pattern, next_line)
      directive = directive[2] if directive else None
      next_line = re.sub(directive_pattern, "", next_line)

      # Parse the rest into four fields:
      event_id, dom, tod, text = next_line.split(' ', maxsplit=3)
      _, event_id = event_id.split(':')

      # Possibly put the event into the reminder queue:
      year, month, day = dom.split('-')
      hour, minute = tod.split(':')
      appt_date = datetime(year=int(year), month=int(month), day=int(day), hour=int(hour),
                           minute=int(minute))

      if curr_date >= appt_date:
        # Mark it as a dev event if we are running in dev_mode:
        if dev_mode and not text.endswith('[DEV]"'):
          text = text.strip('"')
          text = f'"{text} [DEV]"'

        # If the directive indicates that this ID is pending or processed, remove it from the
        # reminder queue:
        if directive in ["PENDING", "PROCESSED"]:
          reminder_queue.pop(f"{event_id}", None)
        else:
          # Otherwise add it to the reminder queue:
          reminder_queue[f"{event_id}"] = f"{text}"

    for (id_to_send, text_to_send) in reminder_queue.items():
      remind_prog = "remind -t" if text_mode else "remind"
      remind_prog = f"./{remind_prog}" if dev_mode else remind_prog
      command = f"{remind_prog} {calfile.name} {id_to_send} {text_to_send}"
      if text_mode:
        output = subprocess.run(command, shell=True, capture_output=True)
        print(output.stdout.decode().strip('\n'))
      else:
        # Run the command in the background:
        command = f"{command} &"
        output = subprocess.run(command, shell=True)

    calfile.close()
    if once_only and iterated_once:
      break
    time.sleep(sleep_secs)


if __name__ == "__main__":
  default_calfile = f"{str(Path.home())}/.mycalendar.txt"
  default_pausefile = f"{str(Path.home())}/.pause_mccal"
  default_sleep = 300

  parser = argparse.ArgumentParser(description="Simple reminder calendar -- findappointment")
  parser.add_argument(
    '--cal_file', metavar='FILE',
    help=f"read from the calendar FILE instead of from '{default_calfile}'"
  )
  parser.add_argument(
    '--pause_file', metavar='FILE',
    help=(f"use the existence of FILE, instead of '{default_pausefile}', as an indication "
          "to findappointment that it should postpone any user notifications until the next "
          "iteration")
  )
  parser.add_argument(
    '--sleep', metavar='N',
    help=(f"sleep for N seconds, instead of the default {default_sleep}, between "
          "iterations"),
    type=int
  )
  parser.add_argument(
    '--text_mode',
    help="write all reminder notifications to the console",
    action='store_true'
  )
  parser.add_argument(
    '--mail',
    help="send an email to the configured addressee in addition to a notification",
    action='store_true'
  )
  parser.add_argument(
    '--once',
    help=('do not iterate; look once through the calendar file for reminders that are due, '
          'generate notifications, and exit.'),
    action='store_true'
  )
  parser.add_argument(
    '--dev',
    help='assume that all other mccal commands are in the working directory',
    action='store_true'
  )
  args = parser.parse_args()

  main(
    args.cal_file or default_calfile,
    args.pause_file or default_pausefile,
    args.sleep or default_sleep,
    args.text_mode,
    args.mail,
    args.once,
    args.dev
  )
